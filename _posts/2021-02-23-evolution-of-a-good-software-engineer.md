---
layout: post
title:  "Anatomy of a Software Engineer: Specialist of Generalism"
date:   2021-02-26 10:00:10 +0000
categories: [engineering, software, software engineering]
permalink: /a-software-engineer-anatomy/
thumb : I needed to find out whether forecast reports had affected Istanbul stock market's closing prices. I just wanted to try what can be done with time series analysis methods..
author : "Erkut Evirgen"
mediaType : image
mediaSource : /style/images/p4-anatomy.png
mediaListImage : /style/images/p4-anatomy.png
---
It has been about 5500 cubic years since the wheel, one of the most genuine engineering wonders, was invented. The paper is about 2200 years old. The electricity is about 140, transistors reflect 100 cubic years. Just 60 years have passed since the years when software engineering in its own form was known as engineering. Computer scientist and engineer [Margaret Hamilton](https://en.wikipedia.org/wiki/Margaret_Hamilton_(software_engineer)){:target="_blank"}  used the term "Information Engineering" for the first time to build navigation systems for Apollo missions. The start of the master's degree in computer engineering at Seattle University took place in 1979 and the Island Programming Language first appeared in 1980. The Rochester Institute of Technology opened its first bachelor's degree programme in software development in 1996. The IEEE version of ["Software Engineering Body of Knowledge (SWEBOK)"](https://cs.fit.edu/~kgallagher/Schtick/Serious/SWEBOKv3.pdf){:target="_blank"} was published in the same year, 1996.

When opposed to other engineering branches of human culture, computer engineering is a very young discipline. Yet, in history, no other engineering division has evolved so rapidly on the world we have encountered, including the subjects he affected. Engineering devices have benefited positively, from maritime radar to magnetic navigation, photoreceptors to medical and biology. The predictability of the world of other branches was what distinguished him from other engineering branches. Software development engineering has continued to evolve as a discipline that has to be applied in a world where the laws of physics have changed weekly.

The only source I had for the integration of a security dongle that I used to create for a distribution business was the dongle manufacturer's code manual at my desk and an email address to contact them when needed. It was a great experience for me to develop this application down, to be able to transfer this knowledge that I have learned after some time to my colleagues, or to give it to other engineers that need it. And that information was of great importance.
But now, the platforms like Google and StackOverflow etc simplified stuff with copy and paste, we do a lot. Now we don't need to explicitly form algorithms that include calculation, trigonometry, and differential equations. We ought to be more relaxed, maybe. We couldn't relax, though. Since the challenges faced by current software engineers have become more complicated and demands have risen: Topics such as "Cross Platform", "Asynchronous method", "Security", "DevOps", "Distributed systems", "Asynchronous process", "Data processing" are supposed to be familiar with other topics that cannot be counted in accordance with Microservice Architectures, Domain Driven Development, Reactive Programming, Test Driven Development, Test/Data-intensive Development Environments, Containers, Orchestration Tools, and even more. Products can now be built to be open to millions, not, as before, to a small number of consumers.

An engineer who has no knowledge of TCP/IP literally writes a back-end service that runs on the architecture of Microservice on a DevOps-supported project without being aware of the cloud systems, he is currently making the software engineer a market-wide non-preferred engineer. He/she can save the day, so it won't take long.

Years ago, I recall that when using Kylix in an ERP development team for a textile factory, I wrote an updater to get the final version of the executable file for the client from the internal network each time the application is started. It was so unusual and exceptional that even an engineer himself was online all the time. The offline use of software and offline individuals are extra-ordinary and exceptional today.

Develop a new programming language was a very idealist and a romantic process. Knowledge of execution paradigms, writing a compiler or interpreter. The people who did this were the heroes of the academic world and they the people of distinction. However, now, this situation can sometimes even be a weekend hobby of a young developer. There are dozens of new programming languages coming to the market every year, and some have set themselves up to learn a new programming language every year.

**Things are changing constantly. Often unpredictable.**

There is a special reason for every young computer engineer to choose this career. Some have made this decision as the wind blows on the market, others are lost themselves in the magic of the computers from a very young ages, and some believe they're just going to earn some money or status. There are also those who choose this career, either with the pressure or encouragement of their families, or according to the most difficult departments of college to join.

Nevertheless, if you have taken steps in this engineering discipline in some way, and you want to make yourself not only today, but one where others and people always want to operate, you need to be mindful that it is important for your own career to react too quickly to the forecasts. And I strongly believe the burden needs to be felt by you.

In order to remain valuable in the industry for a long time, without compromising, it is important to aim at getting certain engineering concepts. Here are some highlights that make you important today from these engineering notions:

##### Time Optimization

The paradigms are evolving so rapidly that all the additional benefits it can get from stock libraries and all the helpful resources need to be learned now, and not waste time mastering the stuff that won't work. Similarly, improving your ability to recognise what needs to be specialised is important. For example, recognising that knowledge of distributed VCS systems is now a must, and being competent and adequate about it, but determining if Git is the instrument that is supposed to be "today". The first to write down important/insignificant allocation is understanding when and how to spend the time because I believe this is the most significant detriment in the industry today. It's a remarkable subject to be able to operate the [Pareto Principle](https://en.wikipedia.org/wiki/Pareto_principle){:target="_blank"} effectively.

##### Go for root cause and behind the scenes

It is also a challenge to go to the root cause and behind the scenes to grasp and discern languages, libraries and paradigms. This is generally a matter focused on the analysis of the findings of chronological cause and effect. Respond, for instance: Why does React.js have such popularity? To understand this, the individual must first understand the nature of the Backbone and Component structure, how DOM works, and how DOM Manipulation makes sense of why it is so common. The relationship of chronological cause and effect helps to better understand the technology in question, as well as to understand whether to spend time in that technology or not. So, it's not just about using them, it's also important to know and tell what they are cure for.

##### Deep Focus

It takes deep work and focus to be able **to see a complicated site or stories in simple parts** or **to make them simple**. As technology progresses, anyone who don't develop this skill will probably be behind. To stay in deep focus amongst distractions like mobile notifications, funny youtube videos and whatsapp messages, will be the one of the most distinguishing soft skills in the years to come.

##### Soft Skills

Although experience is even more relevant at times when access to informatin was difficult, now, at t=0, an engineer can now reach any technological or architectural information easily. In return for these experiences of developers who stored this historical information (or aboutique knowledge) in a specific hierarchy, do not have to bear their bad personalities. Software engineers with zero social skills going extinct. Engineers, who are cocky and whose communication skills are not developed, are not preferred by companies regardless of their level of technical level.

##### Knowledge of upcoming technologies (Try and throw away)

I'm talking about a new technology/library/tool immediately being checked and setting it aside and moving on. Trying [Alpha Preview/CTP/Beta](https://stackoverflow.com/a/736475){:target="_blank"} and the latest technologies you see coming up, libraries, tools, devices and reading some articles/manuals makes you much more efficient, desirable, searched and valuable than old days, It's not enough to just hear that.

##### Continuous and Fast Learning

Challenges are very volatile and something new can come up at any time, unpredictable. Learning about something often implies expense, so it's better to move early to break through the learning curve. Remember: "The more you know, the more advantages and differences you get." Don't say "I'll learn it when the time comes." Attending conferences and monitoring universities are focusing on what topics are, It is imperative to join the [IEEE](https://www.ieee.org/){:target="_blank"}  and/or [ACM](https://www.acm.org/){:target="_blank"} and become active and expand the information network. It is necessary to review papers and be active in local organizations. There are engineers who instinctively do it right. But being able to express the theoretical context is also important.

In every software engineer's reading list, these books should also be included:

[Code Complete](https://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670){:target="_blank"},
[Pragmatic Programmer](https://www.amazon.co.uk/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052/){:target="_blank"},
[Clean Code](https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/){:target="_blank"},
[Design Patterns](https://www.amazon.co.uk/Design-patterns-elements-reusable-object-oriented/dp/0201633612/){:target="_blank"},
[Refactoring](https://www.amazon.co.uk/Refactoring-Improving-Existing-Addison-Wesley-Technology/dp/0134757599/){:target="_blank"},
[Don’t Make me Think](https://www.amazon.co.uk/Dont-Make-Think-Revisited-Usability/dp/0321965515/){:target="_blank"},
[Peopleware](https://www.amazon.co.uk/Peopleware-Productive-Projects-Teams-3rd/dp/0321934113){:target="_blank"},
[Mythical Man Month](https://www.amazon.co.uk/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959/){:target="_blank"},
[Algorithm Design Manual](https://www.amazon.co.uk/Algorithm-Design-Manual-Computer-Science/dp/3030542556){:target="_blank"},
[Programming Pearls](https://www.amazon.co.uk/Programming-Pearls-Joe-Bentley/dp/8177588583){:target="_blank"},
[Structure and Interpretation of Computer Programs](https://www.amazon.co.uk/Structure-Interpretation-Computer-Electrical-Engineering/dp/0262510871/){:target="_blank"}

##### Fundamental Principles and Context

To internalize the concepts of SOLID, Design Patterns and more, it is important. Basic data structures must be informed, space and time trade-offs must be informed. It is not only important to know he distinction between Arrays and LinkedList, but to explain implement hash tables and handle the collision. Entire programming stack, hardware (CPU + memory + cache + interrupts + microcode), binary code, compiler, interpretation, garbage collection, problems such as heap stack, memory addressing, multi-threading, concepts of synchronisation need to be acquainted with. It also seems that knowledge of the network protocols, automated/functional/load and UI tests will remain critical and necessary to be a successful and wanted  engineer for a long time in the industry.

##### Failure

And learning how to cope with failure. (If you've never failed, you haven't really tried.) Personally, however, I believe that not all mistakes can be equally forgiven. Lessons learned should be interpreted emotionally-free, and then any risks to be taken should be well-designed.

Traditionally, engineering means, under certain working conditions, constructing, operating or predicting behaviour using scientific principles to design or create any process, instrument or structure, and all that is done is intended for a purposeful use. For software engineers who are currently trying to shape their career, under the conditions available, all the things I mention are about choosing the most suitable solution. Engineers who want to remain valuable should analyze the existing [constraints](https://www.arxterra.com/realistic-constraints-and-engineering-standards/#Constraint){:target="_blank"} well and apply engineering to their own lives in order to achieve the [objective function](https://abaqus-docs.mit.edu/2017/English/SIMACAEANLRefMap/simaanl-c-optobjectives.htm) for their career. When I applied the engineering principles to my own principles based on what I have lived from past to present, I made my inferences that I mentioned in this article. And I hope these conclusions will help those who really care about this issue, in their analysis.
